---
layout: post
title: "自制系统中添加阻塞断点"
date: 2020-11-19 15:43:28 +0800
categories: 2020-11
tags: frida,hook,aosp
img: 
describe: 为了在app启动前hook上所有方法
---

## 0x01:需求

   需求嘛，某app没有activity，没有fragnemt，启动全靠service通信，所以Frida或者objection挂勾上去存在丢失类的问题？
   
   可能是我的版本问题？所以就想着在app加载前就阻塞住，等待挂勾再放行。

## 0x02:思路和准备

   需求很明确了，现在稍微整理下业务流程:
   
   <span id="RESOLUTION_1">1.在系统`创建app进程`时插入自定义方法来阻塞<font color=red size=3>app启动加载其类和资源文件</font></SPAN>
   
   <span id="RESOLUTION_2">2.判断的依据为通过在系统固定目录下是否存在同包名文件</span>
   
   <span id="RESOLUTION_3">3.等待挂勾完成后，通过删除对应的包名文件来放行app启动</span>
   
   嗯，基本就是这逻辑，那么接下来要做的就是<font size=4 color=red>补课</font>
   
   [进程基础](https://www.jianshu.com/p/43309f0dc669)
   
   [Zygote进程的启动流程](https://www.jianshu.com/p/ab9b83a77af6)
   
   [SystemServer进程的创建流程](https://www.jianshu.com/p/9282f5d9c4f0)
   
   [SystemServer进程的启动流程](https://www.jianshu.com/p/99e0b480666a)
   
   [系统应用进程的创建流程](https://www.jianshu.com/p/be7e933927ed)
   
   [Activity启动流程](https://www.jianshu.com/p/501690f88f68)
   
   [AMS介绍](https://www.jianshu.com/p/4a2a6be1e273)
   
   这里提一句，为什么先说这。做逆向会写同层级应用的代码是**`基础`**，你连人家用的依赖库对应的接口都不熟悉，做起来肯定吃力，
   
   而如果涉及到Android系统底层的逻辑，嘿嘿，你要是熟悉就非常顺手，反之就是花时间走弯路。。。
   
   开头3编的课外知识就是某个写rom的老哥整理的笔记，收获颇丰,那么剩下就是根据需求来整理这些知识点了。
   
## 0x03:尝试
   
   如果从一个app开发者的角度，按照需求，一般思路就是定位到startActivity或者startService/bindService来阻塞启动
   
   这里直接点AS的接口，粗略的看源码即可:
   
   ![img](/assets/images/blog/2020-11/aosp_activity_part_1.png)
   
   嗯，activity可以追溯到<font size=4 color=red>Instrumentation.execStartActivity</font>，目前service看不到，先放着，追踪下`ActivityTaskManager.getService()`
   
   就跟进到`IActivityTaskManager`了，不用想，肯定是`ActivityManagerService`
   
   根据[参考资料](https://www.jianshu.com/p/be7e933927ed)
   流程图，下面看看创建app进程时是否合适插入阻塞方法
   
   ![img](/assets/images/blog/2020-11/aosp_activity_part_2.png)
   
   而根据启动流程路线，快进到`AMS.startProcessLocked`的话，就直接步入`Process`这个`native`方法了
   
   ```shell
        private final void startProcessLocked(ProcessRecord app, String hostingType,
            String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) {
            
            int uid = app.uid;
            int[] gids = null;
            ……
             //從PMS服务中查找目标应用对应的权限组
             final IPackageManager pm = AppGlobals.getPackageManager();
                    permGids = pm.getPackageGids(app.info.packageName, app.userId);
                    ……
                    gids = new int[permGids.length + 2];
                    System.arraycopy(permGids, 0, gids, 2, permGids.length);
             ……
             app.gids = gids;
             
             ……
              if (entryPoint == null) entryPoint = "android.app.ActivityThread";
             //调用Process的静态方法启动一个新的进程 
             Process.ProcessStartResult startResult = Process.start(entryPoint,
                    app.processName, uid, uid, gids, debugFlags, mountExternal,
                    app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet,
                    app.info.dataDir, entryPointArgs);

   ```
   如果不考虑需求的，只是按[思路1](#RESOLUTION_1)来，只要在`start`这行代码后面加阻塞方法就行了，但是需求却是service启动app
   
   如果按照需求来，下面的流程，仅仅靠目前的知识是满足不了的，但是不着急，毕竟也才创建进程，类和资源还没加载，还有余地，可能还有更好的地方
   
   <font color=red size=4>下方流程的**代码**只是做个标记，以防万一参考资料丢失，重点在前半部分的流程分析和图解</font>
   
## 0x04:Process
   
   根据[参考资料](https://www.jianshu.com/p/501690f88f68)
   这个流程，无缝的衔接到`Process`
   
   ![img](/assets/images/blog/2020-11/aosp_process_part_1.png)
   
   `Process.start`主要调用的是`ZygoteProcess`的方法，下面弄个调用链
   
   | <font color=red>关键方法</font> | <font color=red>备注</font> |
   | :-: | :-: |
   | Process.start | |
   | ⬇ | ⬇ |
   | ZygoteProcess.start |  |
   | ⬇ | ⬇ |
   | ZygoteProcess.startViaZygote | 构建进程请求参数，并创建socket，这个socket是啥后面补充说明 ｜
   | ⬇ | ⬇ |
   | ZygoteServer.openZygoteSocketIfNeeded | 建立system_server的client，与Zygote通信 |
   | ⬇ | ⬇ |
   | ZygoteServer.connect | 构建socket对接数据流 |
   | ⬇ | ⬇ |
   | ZygoteProcess.zygoteSendArgsAndGetResult | 通过读取socket的输入输出流，来给Process.ProcessStartResult的pid和usingWarpper赋值，并返回 | 
   
   嗯，目前Process的工作已经结束，下面转移到Zygote，特别注意的是`inputStream.readInt()`，博主说<font color=red size=4>如果这里超时，会出现ANR的问题</font>
   
   那么刚才，想在Process.start之后插入阻塞代码的想法也就彻底被否决了，在这里插入阻塞代码会引起`ANR`
   
## 0x05:Zygote

   按找思路，现在是`ZygotePorcess`来处理`Process`发出的`socket`消息，这里就趁机补补课吧
   
   先整理下Android系统的Zygote启动流程:
   
   | <font color=red>关键方法</font> | <font color=red>备注</font> |
   | :-: | :-: |
   | app_main.main | 路径：/frameworks/base/cmds/app_process/app_main.cpp<br/>读取参数，区分执行ZygoteInit、RuntimeInit、app_usage()<br/> |
   | ⬇ | ⬇ |
   | runtime.start | 1.startVm开启虚拟机<br/>2.startReg注册JNI<br/>3.使用jni反射java层main方法<br/> |
   | ⬇ | ⬇ |
   | ZygoteInit.main | 路径:/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java<br/>1.创建ZygoteServer，在Android O上把与Socket的操作都封装到了ZygoteServer类中<br/>2.解析app_main.cpp传来的参数<br/>3.创建一个Server端的Socket，作用是当Zygote进程将SystemServer进程启动后，就会在这个Socket上来等待ActivityManagerService请求，即请求创建我们自己APP应用程序进程<br/>4.预加载类和资源，包括颜色啊，R文件，drawable、类等<br/>5.启动system_server进程，这是上层framework的运行载体，ActivityManagerService就是运行在这个进程里面的<br/>6.开启一个循环，等待着接收ActivityManagerService的请求，随时待命，当接收到创建新进程的请求时立即唤醒并执行相应工作；<br/>  |
   | ⬇ | ⬇ |
   | ZygoteServer.registerServerSocket | 路径:frameworks/base/core/java/com/android/internal/os/ZygoteServer.java<br/>创建一个LocalServerSocket |
   | ⬇ | ⬇ |
   | new LocalServerSocket | 路径:frameworks/base/core/java/android/net/LocalServerSocket.java<br/>实际对象为LocalSocketImpl |
   | ⬇ | ⬇ |
   | ZygoteProcess.connect | 路径:frameworks/base/core/java/android/os/ZygoteProcess.java<br/>对接ZygoteServer，包装输入输出流 |
   
   图片出处为[Zygote进程的启动流程](https://www.jianshu.com/p/ab9b83a77af6)
   特此感谢。。
   ![iShot2020-11-19 18.16.03.png](https://i.loli.net/2020/11/19/O7g896JMoSx2vGP.png)
   
   app_main
   
   ```shell
         /frameworks/base/cmds/app_process/app_main.cpp
         int main(int argc, char* const argv[])
         {
             ......
             // Parse runtime arguments.  Stop at first unrecognized option.
             bool zygote = false;
             bool startSystemServer = false;
             bool application = false;
             String8 niceName;
             String8 className;
         
             ++i;  // Skip unused "parent dir" argument.
               //init.rc中会配置一些参数，这里进行比较设置一些变量走进不同的分支
             while (i < argc) {
                 const char* arg = argv[i++];
                 if (strcmp(arg, "--zygote") == 0) {
                     //启动的是Zygote进程
                     zygote = true;
                     niceName = ZYGOTE_NICE_NAME;
                 } else if (strcmp(arg, "--start-system-server") == 0) {
                     //启动的是system-server进程
                     startSystemServer = true;
                 } else if (strcmp(arg, "--application") == 0) {
                     application = true;
                 } else if (strncmp(arg, "--nice-name=", 12) == 0) {
                     niceName.setTo(arg + 12);
                 } else if (strncmp(arg, "--", 2) != 0) {
                     className.setTo(arg);
                     break;
                 } else {
                     --i;
                     break;
                 }
             }
         
                 .......
                 //设置一个“好听的名字” zygote，之前的名称是app_process
             if (!niceName.isEmpty()) {
                 runtime.setArgv0(niceName.string(), true /* setProcName */);
             }
         
             if (zygote) {
                   //通过runtime启动zygote
                 runtime.start("com.android.internal.os.ZygoteInit", args, zygote);
             } else if (className) {
                 runtime.start("com.android.internal.os.RuntimeInit", args, zygote);
             } else {
                 fprintf(stderr, "Error: no class name or --zygote supplied.\n");
                 app_usage();
                 LOG_ALWAYS_FATAL("app_process: no class name or --zygote supplied.");
             }
         }
   ```
   
   AndroidRuntime
   
   ```shell
        /*
         * Start the Android runtime.  This involves starting the virtual machine
         * and calling the "static void main(String[] args)" method in the class
         * named by "className".
         *
         * Passes the main function two arguments, the class name and the specified
         * options string.
         */
        void AndroidRuntime::start(const char* className, const Vector<String8>& options, bool zygote)
        {
            ALOGD(">>>>>> START %s uid %d <<<<<<\n",
                    className != NULL ? className : "(unknown)", getuid());
            /* start the virtual machine */
            JniInvocation jni_invocation;
            jni_invocation.Init(NULL);
            JNIEnv* env;
            if (startVm(&mJavaVM, &env, zygote) != 0) {
                return;
            }
            onVmCreated(env);
        
            /*
             * Register android functions.
             */
            if (startReg(env) < 0) {
                ALOGE("Unable to register all android natives\n");
                return;
            }
        
            /*
             * We want to call main() with a String array with arguments in it.
             * At present we have two arguments, the class name and an option string.
             * Create an array to hold them.
             */
            jclass stringClass;
            jobjectArray strArray;
            jstring classNameStr;
        
            stringClass = env->FindClass("java/lang/String");
            assert(stringClass != NULL);
            strArray = env->NewObjectArray(options.size() + 1, stringClass, NULL);
            assert(strArray != NULL);
            classNameStr = env->NewStringUTF(className);
            assert(classNameStr != NULL);
            env->SetObjectArrayElement(strArray, 0, classNameStr);
        
            for (size_t i = 0; i < options.size(); ++i) {
                jstring optionsStr = env->NewStringUTF(options.itemAt(i).string());
                assert(optionsStr != NULL);
                env->SetObjectArrayElement(strArray, i + 1, optionsStr);
            }
        
            /*
             * Start VM.  This thread becomes the main thread of the VM, and will
             * not return until the VM exits.
             */
            char* slashClassName = toSlashClassName(className);
            jclass startClass = env->FindClass(slashClassName);
            if (startClass == NULL) {
                ALOGE("JavaVM unable to locate class '%s'\n", slashClassName);
                /* keep going */
            } else {
                jmethodID startMeth = env->GetStaticMethodID(startClass, "main",
                    "([Ljava/lang/String;)V");
                if (startMeth == NULL) {
                    ALOGE("JavaVM unable to find main() in '%s'\n", className);
                    /* keep going */
                } else {
                    env->CallStaticVoidMethod(startClass, startMeth, strArray);
        
        #if 0
                    if (env->ExceptionCheck())
                        threadExitUncaughtException(env);
        #endif
                }
            }
            free(slashClassName);
           //这行Log比较常见，因为其他应用进程也是由zygote 进程fork 出来的，所有其他进程也包含这段代码，如果其他进程在java 层crash，那么也会走到这里
            ALOGD("Shutting down VM\n");
            if (mJavaVM->DetachCurrentThread() != JNI_OK)
                ALOGW("Warning: unable to detach main thread\n");
            if (mJavaVM->DestroyJavaVM() != 0)
                ALOGW("Warning: VM did not shut down cleanly\n");
        }
        
   
   ```
   
   ZygoteInit
   
   ```shell
        frameworks/base/core/java/com/android/internal/os/ZygoteInit.java
        //1、创建ZygoteServer
        ZygoteServer zygoteServer = new ZygoteServer();
        ...
        // 2、解析app_main.cpp传来的参数
        for (int i = 1; i < argv.length; i++) {
            if ("start-system-server".equals(argv[i])) {
                startSystemServer = true;
            } else if ("--enable-lazy-preload".equals(argv[i])) {
                enableLazyPreload = true;
            } else if (argv[i].startsWith(ABI_LIST_ARG)) {
                abiList = argv[i].substring(ABI_LIST_ARG.length());
            } else if (argv[i].startsWith(SOCKET_NAME_ARG)) {
                socketName = argv[i].substring(SOCKET_NAME_ARG.length());
            } else {
                throw new RuntimeException("Unknown command line argument: " + argv[i]);
            }
        }
        //3、创建一个Server端的Socket
        zygoteServer.registerServerSocket(socketName);
        // In some configurations, we avoid preloading resources and classes eagerly.
        // In such cases, we will preload things prior to our first fork.
        if (!enableLazyPreload) {
            bootTimingsTraceLog.traceBegin("ZygotePreload");
            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_START,
                SystemClock.uptimeMillis());
           //4、加载进程的资源和类
            preload(bootTimingsTraceLog);
            EventLog.writeEvent(LOG_BOOT_PROGRESS_PRELOAD_END,
                SystemClock.uptimeMillis());
            bootTimingsTraceLog.traceEnd(); // ZygotePreload
        } else {
            Zygote.resetNicePriority();
        }
          ........
        if (startSystemServer) {
            //5、开启SystemServer进程，这是受精卵进程的第一次分裂
            startSystemServer(abiList, socketName, zygoteServer);
        }
  
        Log.i(TAG, "Accepting command socket connections");
        //6、启动一个死循环监听来自Client端的消息
        zygoteServer.runSelectLoop(abiList);
        //7、关闭SystemServer的Socket
        zygoteServer.closeServerSocket();
        ...
   ```

   ZygoteServer
   
   ```shell
    frameworks/base/core/java/com/android/internal/os/ZygoteServer.java
    private static final String ANDROID_SOCKET_PREFIX = "ANDROID_SOCKET_";

    private LocalServerSocket mServerSocket;
    /**
     * Registers a server socket for zygote command connections
     *
     * @throws RuntimeException when open fails
     */
    void registerServerSocket(String socketName) {
        //看起来是用了一个单例
        if (mServerSocket == null) {
            int fileDesc;
            final String fullSocketName = ANDROID_SOCKET_PREFIX + socketName;
            try {
                //从环境变量中获取名为ANDROID_SOCKET_zygote的fd
                String env = System.getenv(fullSocketName);
                fileDesc = Integer.parseInt(env);
            } catch (RuntimeException ex) {
                throw new RuntimeException(fullSocketName + " unset or invalid", ex);
            }

            try {
                //构建JAVA中的FD对象
                FileDescriptor fd = new FileDescriptor();
                fd.setInt$(fileDesc);
               //用上面的FD创建LocalServerSocket
                mServerSocket = new LocalServerSocket(fd);
            } catch (IOException ex) {
                throw new RuntimeException(
                        "Error binding to local socket '" + fileDesc + "'", ex);
            }
        }
    }
   ```
    
   LocalServerSocket
   
   ```shell
        frameworks/base/core/java/android/net/LocalServerSocket.java
            /**
            * Creates a new server socket listening at specified name.
            * On the Android platform, the name is created in the Linux
            * abstract namespace (instead of on the filesystem).
            * 
            * @param name address for socket
            * @throws IOException
            */
           public LocalServerSocket(FileDescriptor fd) throws IOException
           {
               impl = new LocalSocketImpl(fd);
               impl.listen(LISTEN_BACKLOG);
               localAddress = impl.getSockAddress();
           }

   ```
    
   ZygoteProcess.connect

   ```shell
        frameworks/base/core/java/android/os/ZygoteProcess.java
                public static ZygoteState connect(String socketAddress) throws IOException {
                    DataInputStream zygoteInputStream = null;
                    BufferedWriter zygoteWriter = null;
                    final LocalSocket zygoteSocket = new LocalSocket();
        
                    try {
                        zygoteSocket.connect(new LocalSocketAddress(socketAddress,
                                LocalSocketAddress.Namespace.RESERVED));
        
                        zygoteInputStream = new DataInputStream(zygoteSocket.getInputStream());
        
                        zygoteWriter = new BufferedWriter(new OutputStreamWriter(
                                zygoteSocket.getOutputStream()), 256);
                    } catch (IOException ex) {
                        try {
                            zygoteSocket.close();
                        } catch (IOException ignore) {
                        }
        
                        throw ex;
                    }
        
                    String abiListString = getAbiList(zygoteWriter, zygoteInputStream);
                    Log.i("Zygote", "Process: zygote socket " + socketAddress + " opened, supported ABIS: "
                            + abiListString);
        
                    return new ZygoteState(zygoteSocket, zygoteInputStream, zygoteWriter,
                            Arrays.asList(abiListString.split(",")));
                }
   ```
   
   下面主要分析ZygoteInit.main这个方法

## 0x06:system_server PART Ⅰ
    
   | <font color=red>关键方法</font> | <font color=red>备注</font> |
   | :-: | :-: |
   | ZygoteServer.main | asd |
   | ⬇ | ⬇ |
   | ZygoteServer.startSystemServer | 创建system_server进程<br/> |
   | ⬇ | ⬇ |
   | Zygote.forkSystemServer | 路径:<br/>/frameworks/base/core/java/com/android/internal/os/Zygote.java<br/>本质通过调用native层nativeForkSystemServer方法来创建进程<br/> |
   | ⬇ | ⬇ |
   | com_android_internal_os_Zygote_nativeForkSystemServer | 路径:<br/>/frameworks/base/core/jni/com_android_internal_os_Zygote.cpp<br/> |
   | ⬇ | ⬇ |
   | ForkAndSpecializeCommon | 创建进程的核心方法，设置进程的各种参数<br/>调用方法:Zygote.SetSigChldHandler<br/>用于保障system_server和Zygote相互存活，任意一个崩溃都会导致相互重启<br/> |
   | ⬇ | ⬇ |
   | handleSystemServerProcess | 路径:<br/>/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java<br/>设置进程名，处理Dalvik虚拟机残留的dex问题，调用Zygote.init<br/> |
   | ⬇ | ⬇ |
   | Zygote.init | 集中调用RuntimeInit类的方法 |
   | ⬇ | ⬇ |
   | RuntimeInit.redirectLogStreams | 初始化Android LOG输出流, 并且将system.out, system.err关闭, 将两者重新定向到Android log中<br/> |
   | ⬇ | ⬇ |
   | RuntimeInit.commonInit | 设置进程出错堆栈的捕获方式。<br/>发生JE问题，弹窗提醒用户。 |
   | ⬇ | ⬇ |
   | RuntimeInit.nativeZygoteInit | native方法，调用链:<br/>AndroidRuntime<br/>.register_com_android_internal_os_ZygoteInit<br/>⬇<br/>AndroidRuntime<br/>.com_android_internal_os_ZygoteInit_nativeZygoteInit<br/>⬇<br/>app_main.onZygoteInit<br/>⬇<br/>ProcessState.startThreadPool<br/>⬇<br/>ProcessState.spawnPooledThread<br/>⬇<br/>ProcessState.makeBinderThreadName<br/>主要开启Binder线程池 |
   | ⬇ | ⬇ |
   | RuntimeInit.applicationInit | 通过调用RuntimeInit.invokeStaticMain，反射com.android.server.SystemServer构造，将其main方法通过Zygote.MethodAndArgsCaller异常抛出  |
   | ⬇ | ⬇ |
   | Zygote.MethodAndArgsCaller.run | 路径:<br/>frameworks/base/core/java/com/android/internal/os/ZygoteInit.java<br/>本质调用com.android.server.SystemServer的main方法<br/>至于为什么通过抛出异常来实现调用，<font size=3.5 color=red>有说为了清楚运行中积攒的栈帧信息</font> |
   
   图片出处为[SystemServer进程的创建流程](https://www.jianshu.com/p/9282f5d9c4f0) 特此感谢。。   
   ![img](/assets/images/blog/2020-11/aosp_process_part_2.png)
   
   ZygoteServer.startSystemServer
   
   ```shell
      /**
       * Prepare the arguments and fork for the system server process.
       */
      private static boolean startSystemServer(String abiList, String socketName, ZygoteServer zygoteServer)
              throws Zygote.MethodAndArgsCaller, RuntimeException {
             .........
          /* Hardcoded command line to start the system server */
          String args[] = {
              "--setuid=1000",
              "--setgid=1000",
              "--setgroups=1001,1002,1003,1004,1005,1006,1007,1008,1009,1010,1018,1021,1023,1032,3001,3002,3003,3006,3007,3009,3010",
              "--capabilities=" + capabilities + "," + capabilities,
              "--nice-name=system_server",
              "--runtime-args",
              "com.android.server.SystemServer",
          };
          ZygoteConnection.Arguments parsedArgs = null;
  
          int pid;
  
          try {
              parsedArgs = new ZygoteConnection.Arguments(args);
              ZygoteConnection.applyDebuggerSystemProperty(parsedArgs);
              ZygoteConnection.applyInvokeWithSystemProperty(parsedArgs);
  
              //创建System进程，底层调用fork函数
              pid = Zygote.forkSystemServer(
                      parsedArgs.uid, parsedArgs.gid,
                      parsedArgs.gids,
                      parsedArgs.debugFlags,
                      null,
                      parsedArgs.permittedCapabilities,
                      parsedArgs.effectiveCapabilities);
          } catch (IllegalArgumentException ex) {
              throw new RuntimeException(ex);
          }
  
          //fork函数会返回两次，pid==0意味着子进程创建成功
          if (pid == 0) {
              //如果机器支持32位应用，需要等待32位的Zygote连接成功
              if (hasSecondZygote(abiList)) {
                  waitForSecondaryZygote(socketName);
              }
              //关闭从Zygote进程继承来的Socket
              zygoteServer.closeServerSocket();
                //处理SytemServer进程接下来的事情，见3.4小节
              handleSystemServerProcess(parsedArgs);
          }
  
          return true;
      }
   ```

   Zygote
   
   ```shell
      /frameworks/base/core/java/com/android/internal/os/Zygote.java
      public static int forkSystemServer(int uid, int gid, int[] gids, int debugFlags,
              int[][] rlimits, long permittedCapabilities, long effectiveCapabilities) {
          VM_HOOKS.preFork();
          // Resets nice priority for zygote process.
          resetNicePriority();
          int pid = nativeForkSystemServer(
                  uid, gid, gids, debugFlags, rlimits, permittedCapabilities, effectiveCapabilities);
          // Enable tracing as soon as we enter the system_server.
          if (pid == 0) {
              Trace.setTracingEnabled(true);
          }
          VM_HOOKS.postForkCommon();
          return pid;
      }
     
      /frameworks/base/core/jni/com_android_internal_os_Zygote.cpp
      static jint com_android_internal_os_Zygote_nativeForkSystemServer(
              JNIEnv* env, jclass, uid_t uid, gid_t gid, jintArray gids,
              jint debug_flags, jobjectArray rlimits, jlong permittedCapabilities,
              jlong effectiveCapabilities) {
        pid_t pid = ForkAndSpecializeCommon(env, uid, gid, gids,
                                            debug_flags, rlimits,
                                            permittedCapabilities, effectiveCapabilities,
                                            MOUNT_EXTERNAL_DEFAULT, NULL, NULL, true, NULL,
                                            NULL, NULL, NULL);
        if (pid > 0) {
            // The zygote process checks whether the child process has died or not.
            ALOGI("System server process %d has been created", pid);
            gSystemServerPid = pid;
            // There is a slight window that the system server process has crashed
            // but it went unnoticed because we haven't published its pid yet. So
            // we recheck here just to make sure that all is well.
            int status;
            if (waitpid(pid, &status, WNOHANG) == pid) {
                ALOGE("System server process %d has died. Restarting Zygote!", pid);
                RuntimeAbort(env, __LINE__, "System server process has died. Restarting Zygote!");
            }
        }
        return pid;
      }
    

      // Utility routine to fork zygote and specialize the child process.
      static pid_t ForkAndSpecializeCommon(JNIEnv* env, uid_t uid, gid_t gid, jintArray javaGids,
                                           jint debug_flags, jobjectArray javaRlimits,
                                           jlong permittedCapabilities, jlong effectiveCapabilities,
                                           jint mount_external,
                                           jstring java_se_info, jstring java_se_name,
                                           bool is_system_server, jintArray fdsToClose,
                                           jintArray fdsToIgnore,
                                           jstring instructionSet, jstring dataDir) {
          //设置子进程的signal信号处理函数，见3.3小节
        SetSigChldHandler();        
        ......
           //fork子进程
        pid_t pid = fork();
      
        if (pid == 0) {
          // The child process.
          ......
          if (!is_system_server) {
              int rc = createProcessGroup(uid, getpid());
              if (rc != 0) {
                  if (rc == -EROFS) {
                      ALOGW("createProcessGroup failed, kernel missing CONFIG_CGROUP_CPUACCT?");
                  } else {
                      ALOGE("createProcessGroup(%d, %d) failed: %s", uid, pid, strerror(-rc));
                  }
              }
          }
      
          SetGids(env, javaGids);//设置设置group
      
          SetRLimits(env, javaRlimits);//设置资源limit
      
          int rc = setresgid(gid, gid, gid);
          if (rc == -1) {
            ALOGE("setresgid(%d) failed: %s", gid, strerror(errno));
            RuntimeAbort(env, __LINE__, "setresgid failed");
          }
      
          rc = setresuid(uid, uid, uid);//设置uid
         .......
      
          SetCapabilities(env, permittedCapabilities, effectiveCapabilities, permittedCapabilities);
      
          SetSchedulerPolicy(env);//设置调度策略
      
             .......
            //创建selinux上下文
          rc = selinux_android_setcontext(uid, is_system_server, se_info_c_str, se_name_c_str);
             .......
        } else if (pid > 0) {
             .......
          }
        }
        return pid;
      }
      }  // anonymous namespace

   ```
   ZygoteInit
   
   ```shell
      /frameworks/base/core/java/com/android/internal/os/ZygoteInit.java
      /**
       * Finish remaining work for the newly forked system server process.
       */
      private static void handleSystemServerProcess(
              ZygoteConnection.Arguments parsedArgs)
              throws Zygote.MethodAndArgsCaller {
              // set umask to 0077 so new files and directories will default to owner-only permissions.
          Os.umask(S_IRWXG | S_IRWXO);
          //设置新进程的名字
          if (parsedArgs.niceName != null) {
              Process.setArgV0(parsedArgs.niceName);
          }
         //获取systemServerClasspath
          final String systemServerClasspath = Os.getenv("SYSTEMSERVERCLASSPATH");
          if (systemServerClasspath != null) {
                 //优化systemServerClasspath路径之下的dex文件，看延伸阅读
              performSystemServerDexOpt(systemServerClasspath);
              // Capturing profiles is only supported for debug or eng builds since selinux normally
              // prevents it.
              boolean profileSystemServer = SystemProperties.getBoolean(
                      "dalvik.vm.profilesystemserver", false);
              if (profileSystemServer && (Build.IS_USERDEBUG || Build.IS_ENG)) {
                  try {
                      File profileDir = Environment.getDataProfilesDePackageDirectory(
                              Process.SYSTEM_UID, "system_server");
                      File profile = new File(profileDir, "primary.prof");
                      profile.getParentFile().mkdirs();
                      profile.createNewFile();
                      String[] codePaths = systemServerClasspath.split(":");
                      VMRuntime.registerAppInfo(profile.getPath(), codePaths);
                  } catch (Exception e) {
                      Log.wtf(TAG, "Failed to set up system server profile", e);
                  }
              }
          }
         //此处是空，所以是eles分之
          if (parsedArgs.invokeWith != null) {
              String[] args = parsedArgs.remainingArgs;
              // If we have a non-null system server class path, we'll have to duplicate the
              // existing arguments and append the classpath to it. ART will handle the classpath
              // correctly when we exec a new process.
              if (systemServerClasspath != null) {
                  String[] amendedArgs = new String[args.length + 2];
                  amendedArgs[0] = "-cp";
                  amendedArgs[1] = systemServerClasspath;
                  System.arraycopy(args, 0, amendedArgs, 2, args.length);
                  args = amendedArgs;
              }
                  WrapperInit.execApplication(parsedArgs.invokeWith,
                      parsedArgs.niceName, parsedArgs.targetSdkVersion,
                      VMRuntime.getCurrentInstructionSet(), null, args);
          } else {
              ClassLoader cl = null;
              if (systemServerClasspath != null) {
                  cl = createPathClassLoader(systemServerClasspath, parsedArgs.targetSdkVersion);
                      Thread.currentThread().setContextClassLoader(cl);
              }
                  /*
               * Pass the remaining arguments to SystemServer.见3.5小节
               */
              ZygoteInit.zygoteInit(parsedArgs.targetSdkVersion, parsedArgs.remainingArgs, cl);
          }
              /* should never reach here */
      }


      public static final void zygoteInit(int targetSdkVersion, String[] argv,
                ClassLoader classLoader) throws Zygote.MethodAndArgsCaller {
            if (RuntimeInit.DEBUG) {
                Slog.d(RuntimeInit.TAG, "RuntimeInit: Starting application from zygote");
            }
                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, "ZygoteInit");
            RuntimeInit.redirectLogStreams();

            RuntimeInit.commonInit();

            ZygoteInit.nativeZygoteInit();

            RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader);
        }
   ```
   
   RuntimeInit
   
   ```shell

      /frameworks/base/core/java/com/android/internal/os/RuntimeInit.java
      /**
       * Redirect System.out and System.err to the Android log.
       */
      public static void redirectLogStreams() {
          System.out.close();
          System.setOut(new AndroidPrintStream(Log.INFO, "System.out"));
          System.err.close();
          System.setErr(new AndroidPrintStream(Log.WARN, "System.err"));
      }
      
      protected static final void commonInit() {
        if (DEBUG) Slog.d(TAG, "Entered RuntimeInit!");

        /*
         * set handlers; these apply to all threads in the VM. Apps can replace
         * the default handler, but not the pre handler.
         */
          //设置进程的uncaught exception的处理方法，默认是设置LoggingHandler，输出函数的出错堆栈。见3.5.2.1
        Thread.setUncaughtExceptionPreHandler(new LoggingHandler());
         //进入异常崩溃的处理流程，通知AMS弹窗，见3.5.2.2
        Thread.setDefaultUncaughtExceptionHandler(new KillApplicationHandler());

        /*
         * Install a TimezoneGetter subclass for ZoneInfo.db，设置时区
         */
        TimezoneGetter.setInstance(new TimezoneGetter() {
            @Override
            public String getId() {
                return SystemProperties.get("persist.sys.timezone");
            }
        });
        TimeZone.setDefault(null);

        /*
         * Sets handler for java.util.logging to use Android log facilities.
         * The odd "new instance-and-then-throw-away" is a mirror of how
         * the "java.util.logging.config.class" system property works. We
         * can't use the system property here since the logger has almost
         * certainly already been initialized.
         */
        LogManager.getLogManager().reset();
        new AndroidConfig();

        /*
         * Sets the default HTTP User-Agent used by HttpURLConnection.
         */
        String userAgent = getDefaultUserAgent();
        System.setProperty("http.agent", userAgent);

        /*
         * Wire socket tagging to traffic stats.
         */
        NetworkManagementSocketTagger.install();

        /*
         * If we're running in an emulator launched with "-trace", put the
         * VM into emulator trace profiling mode so that the user can hit
         * F9/F10 at any time to capture traces.  This has performance
         * consequences, so it's not something you want to do always.
         */
        String trace = SystemProperties.get("ro.kernel.android.tracing");
        if (trace.equals("1")) {
            Slog.i(TAG, "NOTE: emulator trace profiling enabled");
            Debug.enableEmulatorTraceOutput();
        }

        initialized = true;
      }

   ```

   ZygoteInit.nativeZygoteInit
   
   ```shell

      /frameworks/base/core/jni/AndroidRuntime.cpp
      
      static const RegJNIRec gRegJNI[] = {
          REG_JNI(register_com_android_internal_os_RuntimeInit),
          REG_JNI(register_com_android_internal_os_ZygoteInit),
        .....
  
      int register_com_android_internal_os_ZygoteInit(JNIEnv* env)
      {
          const JNINativeMethod methods[] = {
              { "nativeZygoteInit", "()V",
                  (void*) com_android_internal_os_ZygoteInit_nativeZygoteInit },
          };
          return jniRegisterNativeMethods(env, "com/android/internal/os/ZygoteInit",
              methods, NELEM(methods));
      }


      static void com_android_internal_os_ZygoteInit_nativeZygoteInit(JNIEnv* env, jobject clazz)
      {
          gCurRuntime->onZygoteInit();
      }     


      /frameworks/base/cmds/app_process/app_main.cpp
      virtual void onZygoteInit()
      {
          sp<ProcessState> proc = ProcessState::self();
          ALOGV("App process: starting thread pool.\n");
          //开启Binder线程池
          proc->startThreadPool();
      }


      /frameworks/native/libs/binder/ProcessState.cpp
      void ProcessState::startThreadPool()
      {
          AutoMutex _l(mLock);
          if (!mThreadPoolStarted) {
              mThreadPoolStarted = true;
              spawnPooledThread(true);
          }
      }
       

      /frameworks/native/libs/binder/ProcessState.cpp
      void ProcessState::spawnPooledThread(bool isMain)
      {
          if (mThreadPoolStarted) {
              String8 name = makeBinderThreadName();
              ALOGV("Spawning new pooled thread, name=%s\n", name.string());
              sp<Thread> t = new PoolThread(isMain);
              t->run(name.string());
          }
      }


      /frameworks/native/libs/binder/ProcessState.cpp
      String8 ProcessState::makeBinderThreadName() {
          int32_t s = android_atomic_add(1, &mThreadPoolSeq);
          pid_t pid = getpid();
          String8 name;
          name.appendFormat("Binder:%d_%X", pid, s);
          return name;
      }
   ```

   RuntimeInit
   
   ```shell
      /frameworks/base/core/java/com/android/internal/os/RuntimeInit.java
      protected static void applicationInit(int targetSdkVersion, String[] argv, ClassLoader classLoader)
              throws Zygote.MethodAndArgsCaller {
          // If the application calls System.exit(), terminate the process
          // immediately without running any shutdown hooks.  It is not possible to
          // shutdown an Android application gracefully.  Among other things, the
          // Android runtime shutdown hooks close the Binder driver, which can cause
          // leftover running threads to crash before the process actually exits.
          nativeSetExitWithoutCleanup(true);
             // We want to be fairly aggressive about heap utilization, to avoid
          // holding on to a lot of memory that isn't needed.
          VMRuntime.getRuntime().setTargetHeapUtilization(0.75f);
          VMRuntime.getRuntime().setTargetSdkVersion(targetSdkVersion);
             final Arguments args;
          try {
              //将com.android.server.SystemServer赋值给startClass
              args = new Arguments(argv);
          } catch (IllegalArgumentException ex) {
              Slog.e(TAG, ex.getMessage());
              // let the process exit
              return;
          }
             // The end of of the RuntimeInit event (see #zygoteInit).
          Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
             // Remaining arguments are passed to the start class's static main
          invokeStaticMain(args.startClass, args.startArgs, classLoader);
      }
    
      private static void invokeStaticMain(String className, String[] argv, ClassLoader classLoader)
              throws Zygote.MethodAndArgsCaller {
          Class<?> cl;
  
          try {
              cl = Class.forName(className, true, classLoader);
          } catch (ClassNotFoundException ex) {
              throw new RuntimeException(
                      "Missing class when invoking static main " + className,
                      ex);
          }
  
          Method m;
          try {
              m = cl.getMethod("main", new Class[] { String[].class });
          } catch (NoSuchMethodException ex) {
              throw new RuntimeException(
                      "Missing static main on " + className, ex);
          } catch (SecurityException ex) {
              throw new RuntimeException(
                      "Problem getting static main on " + className, ex);
          }
  
          int modifiers = m.getModifiers();
          if (! (Modifier.isStatic(modifiers) && Modifier.isPublic(modifiers))) {
              throw new RuntimeException(
                      "Main method is not public and static on " + className);
          }
  
          /*
           * This throw gets caught in ZygoteInit.main(), which responds
           * by invoking the exception's run() method. This arrangement
           * clears up all the stack frames that were required in setting
           * up the process.
           */
          throw new Zygote.MethodAndArgsCaller(m, argv);
      }


      /frameworks/base/core/java/com/android/internal/os/Zygote.java
      public static class MethodAndArgsCaller extends Exception
              implements Runnable {
          /** method to call */
          private final Method mMethod;
  
          /** argument array */
          private final String[] mArgs;
  
          public MethodAndArgsCaller(Method method, String[] args) {
              mMethod = method;//构造函数, 将SystemServer的main函数赋值给mMethod

              mArgs = args;
          }
  
          public void run() {
              try {
                   //执行SystemServer的main函数, 从而进入到SystemServer的main方法。
                  mMethod.invoke(null, new Object[] { mArgs });
              } catch (IllegalAccessException ex) {
                  throw new RuntimeException(ex);
              } catch (InvocationTargetException ex) {
                  Throwable cause = ex.getCause();
                  if (cause instanceof RuntimeException) {
                      throw (RuntimeException) cause;
                  } else if (cause instanceof Error) {
                      throw (Error) cause;
                  }
                  throw new RuntimeException(ex);
                  }
              }
          }
      }


   ```


## 0x07 system_server PART Ⅱ

   从SystemServer.run继续

   | <font color=red>关键方法</font> | <font color=red>备注</font> |
   | :-: | :-: |
   | SystemServer.run | 路径:<br/>/frameworks/base/services/java/com/android/server/SystemServer.java<br/>1.检验时间：如果当前时间早于1970年，则设置当前时间为1970年，防止初始化出错。<br/><br/>2.设置系统的语言环境等<br/><br/>3.设置当前虚拟机的运行库路径为persist.sys.dalvik.vm.lib.2<br/><br/>4.设置虚拟机的堆内存，虚拟机堆利用率为0.8<br/><br/>5.调用prepareMainLooper()初始化当前线程的Looper<br/><br/>6.加载libandroid_servers.so库<br/><br/>7.调用createSystemContext()创建System的context<br/><br/>8.创建大管家SystemServiceManager的对象mSystemServiceManager，负责系统Service的管理<br/><br/>9.调用startBootstrapServices();startCoreServices();startOtherServices()，创建和运行系统中所有的服务<br/><br/>10.调用Looper.loop()，开启消息循环<br/><br/> |
   | ⬇ | ⬇ |
   | SystemServer.createSystemContext | 通过调用ActivityThread.systemMain创建2个Context |
   | ⬇ | ⬇ |
   | ActivityThread.systemMain | 创建ActivityThread，并通过attach依附 |
   | ⬇ | ⬇ |
   | new SystemServiceManager | 构建system_server核心内并赋值 |
   | ⬇ | ⬇ |
   | LocalServices.addService | 添加服务并运行 |
   
   SystemServer
   
   ```shell
      /frameworks/base/services/java/com/android/server/SystemServer.java
      private void run() {
          try {
              traceBeginAndSlog("InitBeforeStartServices");
              // If a device's clock is before 1970 (before 0), a lot of
              // APIs crash dealing with negative numbers, notably
              // java.io.File#setLastModified, so instead we fake it and
              // hope that time from cell towers or NTP fixes it shortly.
              //1、首先判断系统当前时间，为防止一些和时间相关的初始化出错，若当前时间小于1970年1月1日，设置系统当前时间为该时间点。
              if (System.currentTimeMillis() < EARLIEST_SUPPORTED_TIME) {
                  Slog.w(TAG, "System clock is before 1970; setting to 1970.");
                  SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME);
              }
  
  
              // If the system has "persist.sys.language" and friends set, replace them with
              // "persist.sys.locale". Note that the default locale at this point is calculated
              // using the "-Duser.locale" command line flag. That flag is usually populated by
              // AndroidRuntime using the same set of system properties, but only the system_server
              // and system apps are allowed to set them.
              //
              // NOTE: Most changes made here will need an equivalent change to
              // core/jni/AndroidRuntime.cpp
               //2、设置系统的语言环境等 
              if (!SystemProperties.get("persist.sys.language").isEmpty()) {
                  final String languageTag = Locale.getDefault().toLanguageTag();
  
                  SystemProperties.set("persist.sys.locale", languageTag);
                  SystemProperties.set("persist.sys.language", "");
                  SystemProperties.set("persist.sys.country", "");
                  SystemProperties.set("persist.sys.localevar", "");
              }
  
  
             //3、设置当前虚拟机的运行库路径
              SystemProperties.set("persist.sys.dalvik.vm.lib.2", VMRuntime.getRuntime().vmLibrary());
  
  
              // Mmmmmm... more memory!
              VMRuntime.getRuntime().clearGrowthLimit();
  
              // The system server has to run all of the time, so it needs to be
              // as efficient as possible with its memory usage.
                //4、 设置虚拟机堆内存
              VMRuntime.getRuntime().setTargetHeapUtilization(0.8f);
  
              // Some devices rely on runtime fingerprint generation, so make sure
              // we've defined it before booting further.
              Build.ensureFingerprintProperty();
  
              // Within the system server, it is an error to access Environment paths without
              // explicitly specifying a user.
              Environment.setUserRequired(true);
  
              // Within the system server, any incoming Bundles should be defused
              // to avoid throwing BadParcelableException.
              BaseBundle.setShouldDefuse(true);
  
              // Ensure binder calls into the system always run at foreground priority.
              BinderInternal.disableBackgroundScheduling(true);
  
              // Increase the number of binder threads in system_server
              BinderInternal.setMaxThreads(sMaxBinderThreads);
  
              // Prepare the main looper thread (this thread).
                 //5、设置线程优先级
              android.os.Process.setThreadPriority(
                  android.os.Process.THREAD_PRIORITY_FOREGROUND);
              android.os.Process.setCanSelfBackground(false);
                 //6、 初始化主线程Looper
              Looper.prepareMainLooper();
  
              // Initialize native services.
                //7、 装载libandroid_servers.so库
              System.loadLibrary("android_servers");
  
              // Check whether we failed to shut down last time we tried.
              // This call may not return.
              performPendingShutdown();
  
              // Initialize the system context.
                //8、 创建System的context
              createSystemContext();
  
              // Create the system service manager.
               //9、 创建SystemServiceManager，负责服务的启动
              mSystemServiceManager = new SystemServiceManager(mSystemContext);
              mSystemServiceManager.setRuntimeRestarted(mRuntimeRestart);
              LocalServices.addService(SystemServiceManager.class, mSystemServiceManager);
              // Prepare the thread pool for init tasks that can be parallelized
              SystemServerInitThreadPool.get();
          } finally {
                  traceEnd();  // InitBeforeStartServices
              }
      
              //10、Start services. 真正的开启服务了
              try {
                  traceBeginAndSlog("StartServices");
                  startBootstrapServices();
                  startCoreServices();
                  startOtherServices();
                  SystemServerInitThreadPool.shutdown();
              } catch (Throwable ex) {
                  Slog.e("System", "******************************************");
                  Slog.e("System", "************ Failure starting system services", ex);
                  throw ex;
              } finally {
                  traceEnd();
              }
      
      
      
              //11、 进入Loop循环，处理消息循环
              Looper.loop();
              throw new RuntimeException("Main thread loop unexpectedly exited");
          }



      private void createSystemContext() {
           ActivityThread activityThread = ActivityThread.systemMain();
           mSystemContext = activityThread.getSystemContext();
           mSystemContext.setTheme(DEFAULT_SYSTEM_THEME);
    
           final Context systemUiContext = activityThread.getSystemUiContext();
           systemUiContext.setTheme(DEFAULT_SYSTEM_THEME);
      }

   ```

   ActivityThread
   
   ```shell
      /frameworks/base/core/java/android/app/ActivityThread.java
      public static ActivityThread systemMain() {
          // The system process on low-memory devices do not get to use hardware
          // accelerated drawing, since this can add too much overhead to the
          // process.
          if (!ActivityManager.isHighEndGfx()) {
              ThreadedRenderer.disable(true);
          } else {
              ThreadedRenderer.enableForegroundTrimming();
          }
          ActivityThread thread = new ActivityThread();
          thread.attach(true);
          return thread;
      }

      private void attach(boolean system) {
          sCurrentActivityThread = this;
          mSystemThread = system;
          if (!system) {
              //如果是个应用，走这里
          } else {
              // Don't set application object here -- if the system crashes,
              // we can't display an alert, we just want to die die die.
              android.ddm.DdmHandleAppName.setAppName("system_process",
                      UserHandle.myUserId());
              try {
                 //对于一个应用进程，该类会优先被创建出来，然后通过他来创建其他组件；另外，它还是系统与组件交互的桥梁，因而通过他可以监听组件和系统之间的各种交互了。
                  mInstrumentation = new Instrumentation();
                 //mPackageInfo是一个LoadedApk对象
                  ContextImpl context = ContextImpl.createAppContext(
                          this, getSystemContext().mPackageInfo);
                  mInitialApplication = context.mPackageInfo.makeApplication(true, null);
                     //Application的onCreate回调，这个Application代表什么呢？
                  mInitialApplication.onCreate();
              } catch (Exception e) {
                  throw new RuntimeException(
                          "Unable to instantiate Application():" + e.toString(), e);
              }
          }
      }



      public ContextImpl getSystemContext() {
           synchronized (this) {
               if (mSystemContext == null) {
                  mSystemContext = ContextImpl.createSystemContext(this);
               }
               return mSystemContext;
           }
      }

   ContextImpl createSystemContext(ActivityThread mainThread) {
            //创建LoadedApk
           LoadedApk packageInfo = new LoadedApk(mainThread);
           ContextImpl context = new ContextImpl(null, mainThread, packageInfo, null, null, null, 0,
                   null);
           context.setResources(packageInfo.getResources());
           context.mResources.updateConfiguration(context.mResourcesManager.getConfiguration(),
                   context.mResourcesManager.getDisplayMetrics());
           return context;
   }
   ```

   到此为止，一个Android系统进程的启动模板已经分析完，在这花大篇幅介绍system_service是因为
   
   启动app虽然调用的是`Process.start`，其本质还是回到了`Zygote.init`，而`Zygote`又和`system_server`是守护关系，所以要花大力气追踪
   
   这里代码只是辅助，主要的还是流程，下面稍微总结下启动的几个关键类和方法，以助于下方app启动的理解